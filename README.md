#Python. Продвинутый курс. НОЦ


##1. Декораторы 1

Ограничение времени 	10 секунд
Ограничение памяти 	64.0 Мб
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt

В первом задании курса предлагается решить классическую задачу с собеседований по питону - написать декоратор, который вычисляет время выполнения оборачиваемой функции. Итак, требования к декоратору:
* декоратор должен называться time_decorator
* он должен вычислять время в секундах, в течение которого выполняется обернутая функция при ее вызове. Количество секунд должно быть выведено сразу после выполнения оборачиваемой функции
* после оборачивания функция должна возвращать тот же результат, который возвращала исходная функция
* пробрасывать аргументы из декоратора в функцию необязательно для выполнения этого задания

###Пример использования декоратора
```python
@time_decorator
def sleep_1_sec():
    time.sleep(1)
    print("function")
    return 25

result = sleep_1_sec()
```
    function
    1
```python
print(result)
```
    25

##2. Декораторы 2
Ограничение времени 	1 секунда
Ограничение памяти 	64.0 Мб
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt

В этом задании требуется написать фабрику декораторов, которые будут логировать вызовы функций. Чтобы не усложнять, в качестве журнала событий будем использовать списки. Требования к фабрике:

* фабрика должна называться logging_decorator
* при создании декоратора фабрика должна принять требуемый список-логгер в аргументах
* обернутая функция должна возвращать тот же результат, который бы вернула оборачиваемая функция
* при вызове обернутой функции в список-логгер должен добавляться словарь, в котором будут храниться название функции, список поданных аргументов, время вызова функции и результат, который она вернула. Формат словаря должен быть таким:

{
    'name': 'test_function',
    'arguments': {'a': 1, 'b': 2},
    'call_time': datetime.datetime(2021, 8, 1, 18, 18, 7, 849184),
    'result': 127
}

Ниже приведен пример использования такого декоратора.
Пример использования декоратора

```python
logger = []  # этот словарь будет хранить наш "лог"

@logging_decorator(logger)  # в аргументы фабрики декораторов подается логгер
def test_simple(a, b=2):
    return 127

test_simple(1)  # при вызове функции в список logger должен добавиться словарь с
                # информацией о вызове функции

print(logger)
```

    [{'name': 'test_simple', 'arguments': {'a': 1, 'b': 2}, 'call_time': datetime.datetime(2021, 8, 1, 18, 18, 7, 849184), 'result': 127}]

####Примечания

Для удобного получения переданных в функцию аргументов при ее вызове можно использовать функцию getcallargs из модуля inspect. Но стоит учесть, что она так или иначе выполняет вызов исследуемой функции, поэтому такой способ плох, если функция изменяет какие-то глобальные состояния. В тестах к этому заданию таких функций нет, поэтому можно попрактиковаться в использовании модуля inspect.
